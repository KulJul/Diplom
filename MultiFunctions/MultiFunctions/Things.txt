1) Что все таки происходит при первом подходе Александреску. Как осуществляется компиляция? 
Сейчас до момента выхова, после разрешения типов у нас по сути происходит то же самое(если убрать поиск таблицы вирт функций
и инициализацию). Будет ли выигрыш если вычислять код ссылки(&obj) заранее и прокидывать в эти функции?


2) Посмотреть что происходит дальше, когда мы разрешаем типы и ищем функцию. 
Тут мы как бы используем второй подход. Есть ли какие то плюсы? В 1 подходе на этом месте используют просто вызов с 
определенными типами. Класс на котором вызывают передается через параметр.


3) Если в третьем подходе Александреску весь выигрыш только за счет массива по сравнению со 2 пододом,
а вычислять хеш нельзя как во втором подходе из-за больших значений, которые не подходят для массива.
То можно подумать как подобрать функцию или какой то механизм чтобы преобразовать эти хеши в меньшие значения.
Заранее можно подбирать в процессе инициализации.

4) Как реализовывать если есть несколько действий. Столкновение и что-то еще. См схему классов.

5) реализация для множества параметров. Тут для первого подхода лучше взять Александреску методы для разрешения.
Чтобы не было этой дикой рекурсии.